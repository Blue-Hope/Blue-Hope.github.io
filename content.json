{"pages":[],"posts":[{"title":"TCP / UDP 소켓 통신을 이용한 채팅 프로그램 개발","text":"TCP / UDP 소켓 프로그래밍을 통해 채팅 프로그램을 개발해보았다. cli를 통해 통신하는 프로세스를 기반으로 gui를 만들어 실제 프로그램 처럼 동작하도록 해보았다. 들어가며우선 언어는 파이썬으로 한다. pyqt5를 사용해 gui를 구성하는 게 편하고, 웬만한 socket 통신과 thread에 대한 구현이 스무스하게 가능하기 때문이다. 사실 TCP 단에서 통신하는 프로그램은 학교 내 OS 연구실에서 개인 프로젝트로 개발해 본 적이 있다. https://github.com/blue-hope/simple_proxy_server 위는 간단한 프록시 서버로 TCP 소켓을 열고 서버로 오가는 패킷을 분석해 중간에서 문서를 수정하는 역할을 한다. 아무튼, TCP 통신에 대해 익숙하니 먼저 다음과 같이 서버와 클라이언트 파일을 만들어 본다. bash``12$ touch server.py $ touch client.py 기본적인 1:1 통신 구현우선 서버와 클라이언트 모두 소켓 모듈을 추가한다. from socket import * 서버는 TCP 소켓 객체를 항상 요청을 받을 수 있는 상태로 둬야한다. python argparse를 이용해 통신을 할 포트번호와 한번에 서버에 연결되는 클라이언트 최대 수 backlog를 설정한다. SOCK_STREAM을 사용해 TCP 소켓을 열고 로컬호스트와 포트번호를 바인딩한다. 이 소켓이 그 포트번호를 사용한다는 의미이다. 마지막으로 소켓을 listen 상태로 만들어 서버가 연결을 항시 기다릴 수 있도록 한다. server.py``123serverSock = socket(AF_INET, SOCK_STREAM)serverSock.bind((&apos;&apos;, args.port))serverSock.listen(args.backlog) 클라이언트도 마찬가지로 SOCK_STREAM 소켓 객체를 만들고, 로컬호스트와 포트를 연결한다. 지금 단계에선 로컬 연결만 사용할 예정이라 일단 로컬호스트 ip를 붙여둔다. 클라이언트가 로컬호스트로 연결되도록하고, 데이터를 보내보도록 한다. user_id를 이용해 유저 관리를 할 예정이라 아래와 같이 짰다. client.py``123clientSock = socket(AF_INET, SOCK_STREAM)clientSock.connect((&apos;127.0.0.1&apos;, args.port))clientSock.send((&apos;user_id:&apos; + str(args.user)).encode(&apos;utf-8&apos;)) 1:1 쓰레드 통신 구현위 단계를 조금 업그레이드 해보자. 쓰레드를 사용하는것이다 일단 이를 구현하기전에 Thread의 개념을 간단히 짚고 가보자. Thread?프로세스 내에서 실행되는 여러 흐름의 단위 쉽게 말해서, 쓰레드는 실행중인 프로세스와 일부 변수를 공유하고, 코드를 공유하는 일종의 복사된 프로세스이다. 만약 쓰레드를 사용하지 않고 통신을 하게 되면 어떻게 될까? 다음 코드를 살펴보자. client.py``12345while True: input_str = input(&apos;&gt;&gt;&gt; &apos;) clientSock.send(input_str.encode(&apos;utf-8&apos;)) data = clientSock.recv(args.max_data_recv).decode(&apos;utf-8&apos;) print(data) 위 코드는 클라이언트에서 꾸준히 인풋 스트링을 받아 소켓에 보내고 돌아오는 데이터를 받는 상황을 가정하고 짜본 것이다. 파이썬은 코드가 순차적으로 실행되기에, 인풋을 받고, 보내고, 돌아오는 메시지를 받는 일련의 과정을 거쳐야 다시 인풋을 받을 수 있다. 이런 순차적인 과정이 아니라 메시지를 받고 보내는걸 독립적으로 시행되게 하려면 어떻게 해야할까? 이 때 사용되는 것이 쓰레드이다. Thread Usageclient.py``123import _thread_thread.start_new_thread(send_thread, (clientSock, args))_thread.start_new_thread(recv_thread, (clientSock, args)) 우선 위와 같이 _thread 모듈을 임포트 하고, 새로운 쓰레드 두개를 연다. 데이터를 인풋으로 받아 보내는 동작을 수행하는 send_thread와 데이터를 받아 커맨드라인에 프린트하는 recv_thread가 동시에 돌아가도록 하는 것이다. client.py``1234def send_thread(_clientSock, args): while True: input_str = input(&apos;&gt;&gt;&gt; &apos;) clientSock.send(input_str.encode(&apos;utf-8&apos;)) 보내는 쓰레드는 위와 같은 함수를 수행한다. client.py``1234def recv_thread(_clientSock, args): while True: data = clientSock.recv(args.max_data_recv).decode(&apos;utf-8&apos;) print(data) 받는 쓰레드는 위와 같은 함수를 수행한다. 이로써 총 3개의 과정이 돌아가게 된다. main 프로세스 send 쓰레드 recv 쓰레드 위 세개는 독립적이라 공유하는 변수를 제외하곤 서로 영향을 끼치지 않는다. 아직은 서버와 클라이언트가 1:1로 통신하기 때문에, 서버에 대한 처리는 일단 보류하도록 한다. 마치며위 삽입된 코드의 풀코드는 github 에서 확인가능하다.","link":"/2019/11/18/network-1/"}],"tags":[],"categories":[{"name":"network","slug":"network","link":"/categories/network/"}]}